<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Causality Graph Text Interface</title>
    <style>
        /* Remove default bullets */
        ul, #myUL {
            list-style-type: none;
        }

        /* Remove margins and padding from the parent ul */
        #myUL {
            margin: 0;
            padding: 0;
        }

        /* Style the caret/arrow */
        .caret {
            cursor: pointer;
            user-select: none; /* Prevent text selection */
        }

        /* Create the caret/arrow with a unicode, and style it */
        .caret::before {
            content: "\25B6";
            color: black;
            display: inline-block;
            margin-right: 6px;
        }

        /* Rotate the caret/arrow icon when clicked on (using JavaScript) */
        .caret-down::before {
            transform: rotate(90deg);
        }

        /* Hide the nested list */
        .nested {
            display: none;
        }

        /* Show the nested list when the user clicks on the caret/arrow (with JavaScript) */
        .active {
            display: block;
        }
    </style>
</head>
<body>
    <script src="lib/causality_graph.js"></script>
    <script src="zip.min.js"></script>
    <script>
        let simulate_purge = Module.cwrap("simulate_purge", "number", ["number"]);
        let simulate_purges_batched = Module.cwrap("simulate_purges_batched", "number", ["number", "number", "number", "number", "number"])
        let show_reachability = Module.cwrap("show_reachability", "number", ["number"]);
        let init = Module.cwrap("init", "number", ["number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number"]);


        let methodList = []
        let transitiveSubNodes = {}

        function simulatePurge(str) {
            let ptr  = allocateUTF8(str)
            let retPtr = simulate_purge(ptr)
            let res = UTF8ToString(retPtr)

            // dealloc memory
            Module._free(ptr);
            Module._free(retPtr);

            return res
        }

        function simulatePurgesBatched(purge_groups) {

            let subsetsArr = new Uint32Array(purge_groups.length * 2)

            let totalCount = 0

            for(let i = 0; i < purge_groups.length; i++) {
                const count = purge_groups[i].length
                totalCount += count
                subsetsArr[i * 2 + 1] = count
            }

            let midsPtr = Module._malloc(totalCount * 4)
            let midsPos = 0

            for(let i = 0; i < purge_groups.length; i++)
            {
                let count = subsetsArr[i * 2 + 1]
                let subsetArr = new Uint32Array(count)
                let pos = 0

                for(const mid of purge_groups[i])
                {
                    subsetArr[pos] = mid + 1
                    pos++
                }

                if(subsetArr.length != pos) {
                    throw new Error()
                }

                assert(subsetArr.length === pos)



                subsetsArr[i*2] = midsPtr + midsPos
                Module.HEAPU32.set(subsetArr, (midsPtr + midsPos) / 4)
                midsPos += count * subsetArr.BYTES_PER_ELEMENT
            }

            let subsetsArrPtr = Module._malloc(subsetsArr.length * subsetsArr.BYTES_PER_ELEMENT)
            Module.HEAPU32.set(subsetsArr, subsetsArrPtr / 4)

            let resultsArrPtr = Module._malloc(purge_groups.length * 4)

            let method_weights_ptr = Module._malloc((codesizes.length + 1) * 4)
            let method_weights_arr = Module.HEAP32.subarray(method_weights_ptr / 4, method_weights_ptr / 4 + codesizes.length + 1)

            method_weights_arr[0] = 0
            for(let i = 0; i < codesizes.length; i++)
                method_weights_arr[i+1] = codesizes[i]

            const status = simulate_purges_batched(subsetsArrPtr, purge_groups.length, method_weights_ptr, method_weights_arr.length, resultsArrPtr)

            let res = Module.HEAPU32.subarray(resultsArrPtr / 4, resultsArrPtr / 4 + purge_groups.length)

            Module._free(method_weights_ptr)
            Module._free(subsetsArrPtr)
            Module._free(midsPtr)
            // Module._free(resultsArrPtr)
            // TODO: Free resultsArrPtr

            return status == 0 ? null : res
        }

        function pressBtn(str) {
            document.getElementById("Output").value = simulatePurge(str)
            printReachability(document.getElementById("Input_reachability").value)
        }

        function printReachability(str){
            let ptr  = allocateUTF8(str)

            let retPtr = show_reachability(ptr)

            document.getElementById("Output_reachability").value = UTF8ToString(retPtr)

            // dealloc memory
            Module._free(ptr);
            Module._free(retPtr);
        }

        const model = (() => {

            return {
                getEntries(file, options) {
                    return (new zip.ZipReader(new zip.BlobReader(file))).getEntries(options);
                },
                async getURL(entry, options) {
                    return URL.createObjectURL(await entry.getData(new zip.BlobWriter(), options));
                }
            };

        })();

        function doSomething(){
            let fileInput = document.getElementById("file-input");
            fileInput.dispatchEvent(new MouseEvent("click"));
            fileInput.onchange = selectFile;
        }

        async function selectFile() {
            try {
                let fileInput = document.getElementById("file-input");
                let selectedFile = fileInput.files[0];
                await loadFiles(selectedFile, "utf-8");
            } catch (error) {
                alert(error);
            }
        }

        function getMethodCodesizeDictFromReachabilityJson(data) {
            let dict = {}

            for (const toplevel of data) {
                for (const package in toplevel.packages) {
                    for (const type in toplevel.packages[package].types) {
                        for (const method in toplevel.packages[package].types[type].methods) {
                            const fullyQualifiedName = package + "." + type + "." + method
                            const codesize = toplevel.packages[package].types[type].methods[method].size
                            dict[fullyQualifiedName] = codesize
                        }
                    }
                }
            }

            return dict
        }

        async function loadFiles(selectedFile, filenameEncoding) {
            let entries = await model.getEntries(selectedFile, { filenameEncoding });
            if (entries && entries.length) {
                filesAsByteArrays = {}

                let reachabilityData = JSON.parse(await entries.find(e => e.filename === "reachability.json").getData(new zip.TextWriter()))
                let methods = await entries.find(e => e.filename === "methods.txt").getData(new zip.TextWriter())
                let methodList = methods.split('\n')
                if(methodList[methodList.length-1].length == 0) {
                    methodList.pop()
                }
                prepareListView(generateHierarchyFromReachabilityJsonAndMethodList(reachabilityData, methodList))
                let codesizesDict = getMethodCodesizeDictFromReachabilityJson(reachabilityData)
                codesizes = new Array(methodList.length)

                for(let i = 0; i < methodList.length; i++) {
                    codesizes[i] = codesizesDict[methodList[i]] ?? 0
                }


                for (const entry of entries) {
                    if(entry.filename === "reachability.json")
                    {
                        continue;
                    }

                    const zipFileWriter = new zip.Uint8ArrayWriter()
                    const data = await entry.getData(zipFileWriter)

                    let input_ptr = Module._malloc(data.length);
                    Module.HEAPU8.set(data, input_ptr);

                    filesAsByteArrays[entry.filename] = { data: input_ptr, length: data.length }
                }

                init(filesAsByteArrays["types.txt"].data, filesAsByteArrays["types.txt"].length,
                    filesAsByteArrays["methods.txt"].data, filesAsByteArrays["methods.txt"].length,
                    filesAsByteArrays["typeflows.txt"].data, filesAsByteArrays["typeflows.txt"].length,
                    filesAsByteArrays["typestates.bin"].data, filesAsByteArrays["typestates.bin"].length,
                    filesAsByteArrays["interflows.bin"].data, filesAsByteArrays["interflows.bin"].length,
                    filesAsByteArrays["direct_invokes.bin"].data, filesAsByteArrays["direct_invokes.bin"].length,
                    filesAsByteArrays["typeflow_methods.bin"].data, filesAsByteArrays["typeflow_methods.bin"].length,
                    filesAsByteArrays["typeflow_filters.bin"].data, filesAsByteArrays["typeflow_filters.bin"].length,
                    filesAsByteArrays["declaring_types.bin"].data, filesAsByteArrays["declaring_types.bin"].length,
                )

                for (const span of Object.values(filesAsByteArrays))
                {
                    Module._free(span.data)
                }
            }
        }
    </script>

    <button title="upload" onClick="doSomething()">Upload CausalityExport</button>

    <details>

        <br/>
        <label for="Input"></label><textarea id="Input" cols="100" rows="5" spellcheck="false" oninput="pressBtn(this.value)"></textarea>
        <label for="Input_reachability"></label><textarea id="Input_reachability" cols="100" rows="5" spellcheck="false" oninput="printReachability(this.value)"></textarea>
        <br/>
        <label for="Output"></label><textarea id="Output" cols="100" spellcheck="false" rows="20" readonly="readonly"></textarea>
        <label for="Output_reachability"></label><textarea id="Output_reachability" cols="100" spellcheck="false" rows="20" readonly="readonly"></textarea>
    </details>

    <input type="file" id="file-input" accept="application/zip" hidden>

    <input type="checkbox">Show generated code</input>

    <ul id="myUL">
        <li id="myLI">
            <span class="caret" id="myRoot">root</span>
        </li>
    </ul>

    <script>
        function generateHierarchyFromReachabilityJsonAndMethodList(json, cgNodes) {
            let dict = { children: [] }

            prefixToNode = {}

            for (const toplevel of json) {
                let l1name = "Ïµ"
                if (toplevel.path && toplevel.module) {
                    l1name = toplevel.path + ":" + toplevel.module
                } else if(toplevel.path) {
                    l1name = toplevel.path
                } else if(toplevel.module) {
                    l1name = toplevel.module
                }

                let l1 = { children: [], name: l1name, fullname: l1name, cg_nodes: [] }
                if (toplevel.path) {
                    prefixToNode[toplevel.path] = l1
                }
                dict.children.push(l1)

                for (const packageName in toplevel.packages) {
                    const package = toplevel.packages[packageName]

                    let prefix = ""

                    let node = l1

                    if(packageName.length !== 0) {
                        for (const subPackageName of packageName.split('.')) {
                            prefix += subPackageName + "."
                            let next = node.children.find(n => n.name === subPackageName)
                            if(!next) {
                                next = { children: [], fullname: prefix, name: subPackageName, cg_nodes: [] }
                                node.children.push(next)
                            }
                            node = next
                        }
                    }


                    let l2 = node

                    for (const typeName in package.types) {
                        const type = package.types[typeName]
                        let l3 = { children: [], fullname: prefix + typeName, name: typeName, cg_nodes: [] }
                        prefixToNode[l3.fullname] = l3
                        l2.children.push(l3)

                        for (const method in type.methods) {
                            let l4 = { fullname: l3.fullname + "." + method, name: method, cg_nodes: [] }
                            prefixToNode[l4.fullname] = l4
                            l3.children.push(l4)
                        }
                    }
                }
            }

            prefixesSorted = Object.keys(prefixToNode).sort((a, b) => b.length - a.length)

            for (let i = 0; i < cgNodes.length; i++) {
                const cgNodeName = cgNodes[i]
                for (const prefix of prefixesSorted) {
                    if (cgNodeName.startsWith(prefix)) {
                        prefixToNode[prefix].cg_nodes.push(i)
                        break;
                    }
                }
            }

            return dict
        }

        function expandClickHandler(element, node) {
            let expanded = element.classList.toggle("caret-down");

            if(!element.parentElement.querySelector(".nested")) {
                if (expanded) {
                    element.parentElement.appendChild(generateHTML(node))
                    let purge_groups = []

                    for (const child of node.children) {
                        let group = []

                        {
                            let stack = []
                            stack.push(child)
                            while (stack.length > 0) {
                                const u = stack.pop()
                                if (u.cg_nodes)
                                    group = group.concat(u.cg_nodes)
                                if (u.children)
                                    stack = stack.concat(u.children)
                            }
                        }

                        purge_groups.push(group)
                    }

                    /*
                    for (e of element.parentElement.querySelector("ul").children) {
                        let node_prefix = e.getAttribute("data-node-name")
                        strs.push(node_prefix)
                    }
                     */

                    let nonempty_purge_groups = purge_groups.filter(g => g.length > 0)
                    nonempty_res = simulatePurgesBatched(nonempty_purge_groups)
                    let res = Array(purge_groups.length)

                    {
                        let i = 0
                        for (let j = 0; j < purge_groups.length; j++) {
                            if (purge_groups[j].length > 0) {
                                res[j] = nonempty_res[i++]
                            } else {
                                res[j] = 0
                            }
                        }
                    }

                    let list = element.parentElement.querySelector('ul')

                    let i = 0
                    for (e of list.children) {
                        let cutoff_size = res[i]
                        let str = ""
                        if(cutoff_size > 1000000)
                            str = (cutoff_size / 1000000).toPrecision(3) + " MB"
                        else if(cutoff_size > 1000)
                            str = (cutoff_size / 1000).toPrecision(3) + " KB"
                        else
                            str = cutoff_size.toPrecision(3) + " B"

                        e.querySelector("#purged").textContent = str
                        i++
                    }

                    let order = new Array(list.children.length)
                    for(let i = 0; i < order.length; i++)
                        order[i] = i

                    let nodes = list.children
                    order.sort((a, b) => res[b] - res[a]).map(i => nodes[i]).forEach(node => list.appendChild(node))
                }
            }

            element.parentElement.querySelector(".nested").classList.toggle("active");
        }

        function generateHTML(data) {
            let ul = document.createElement("ul")
            ul.className = "nested"

            for(const d of data.children) {
                let li = document.createElement("li")
                ul.appendChild(li)
                let span = document.createElement("span")
                li.appendChild(span)
                span.appendChild(document.createTextNode(d.name))
                span.setAttribute("title", d.fullname)
                li.setAttribute("data-node-name", d.fullname)
                let out = document.createElement("span")
                out.style = "margin-left: 25px; color: #808080"
                li.appendChild(out)
                out.id = "purged"
                /*
                let checkbox = document.createElement("input")
                checkbox.setAttribute("type", "checkbox")
                checkbox.setAttribute("data-node-name", prefix + d)
                li.appendChild(checkbox)
                */

                if(d.children) {
                    let node = d
                    span.className = "caret"
                    span.addEventListener("click", () => {
                        expandClickHandler(span, node);
                    });
                }
            }

            return ul
        }

        function prepareListView(data) {
            const rootTreeViewElement = document.getElementById("myRoot")
            rootTreeViewElement.addEventListener("click", () => {
                expandClickHandler(rootTreeViewElement, data)
            })
        }
    </script>
</body>
</html>
